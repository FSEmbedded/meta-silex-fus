From 0a3423c22e9bcce317e031fa5c79076608cb2187 Mon Sep 17 00:00:00 2001
Message-Id: <0a3423c22e9bcce317e031fa5c79076608cb2187.1731000715.git.keller@fs-net.de>
In-Reply-To: <4d28209436179e313629def5ee868419f73d6121.1731000715.git.keller@fs-net.de>
References: <4d28209436179e313629def5ee868419f73d6121.1731000715.git.keller@fs-net.de>
From: Hartmut Keller <keller@fs-net.de>
Date: Thu, 28 Mar 2024 18:09:46 +0100
Subject: [PATCH 3/4] Support newer kernel versions, avoid compiler warnings

Add support for newer toolchains and Linux kernels up to at least 6.1.

- Add linux/ prefix in front of some included headers
- Add checks on LINUX_VERSION_CODE where newer kernels differ
- Add fallthrough to avoid warnings on newer toolchains
- Add dev_addr_mod() and use where MAC addresses are set
- Use timespec64 instead of timespec on newer kernel versions
- Fix some indentations where that were wrong
- Remove some compiler warnings

Also add suffix "-plain" to the version string to emphasise the difference
to the Silex version (done in an extra commit).
---
 CORE/CLD_TXRX/HTT/htt_rx.c                         |   2 +
 CORE/CLD_TXRX/TXRX/ol_rx_defrag.c                  |   2 +-
 CORE/CLD_TXRX/TXRX/ol_rx_reorder.c                 |   2 +-
 CORE/CLD_TXRX/TXRX/ol_tx_send.c                    |   2 +-
 CORE/CLD_TXRX/TXRX/ol_txrx_internal.h              |   2 +-
 CORE/EPPING/src/epping_txrx.c                      |   8 +-
 CORE/HDD/inc/wlan_hdd_ftm.h                        |   2 +-
 CORE/HDD/inc/wlan_hdd_softap_tx_rx.h               |   5 +
 CORE/HDD/inc/wlan_hdd_tx_rx.h                      |   5 +
 CORE/HDD/src/wlan_hdd_assoc.c                      |   5 +
 CORE/HDD/src/wlan_hdd_cfg80211.c                   | 101 ++++++++++++++++++--
 CORE/HDD/src/wlan_hdd_hostapd.c                    |  10 +-
 CORE/HDD/src/wlan_hdd_main.c                       |  56 +++++++++--
 CORE/HDD/src/wlan_hdd_memdump.c                    |  21 ++++-
 CORE/HDD/src/wlan_hdd_softap_tx_rx.c               |   5 +
 CORE/HDD/src/wlan_hdd_tx_rx.c                      |   5 +
 CORE/HDD/src/wlan_hdd_wext.c                       |   1 +
 CORE/HDD/src/wlan_hdd_wmm.c                        |   1 +
 CORE/MAC/inc/qwlan_version.h                       |   2 +-
 CORE/MAC/src/cfg/cfgProcMsg.c                      |   2 +-
 CORE/MAC/src/include/parserApi.h                   |   4 +-
 CORE/MAC/src/pe/lim/limProcessCfgUpdates.c         |   1 +
 CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c     |   1 +
 CORE/SAP/src/sapFsm.c                              |   2 +-
 CORE/SAP/src/sapModule.c                           |   3 +
 CORE/SERVICES/BMI/ol_fw.c                          |  31 ++++++-
 CORE/SERVICES/COMMON/adf/adf_nbuf.c                |   5 +
 CORE/SERVICES/COMMON/adf/adf_os_dma.h              |  28 ++++++
 CORE/SERVICES/COMMON/adf/adf_os_time.h             |   4 +
 CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h    |  62 ++++++++++++-
 CORE/SERVICES/COMMON/adf/linux/qdf_crypto.c        |   8 +-
 CORE/SERVICES/COMMON/adf/qdf_crypto.h              |   4 +
 CORE/SERVICES/COMMON/osapi_linux.h                 |  33 +++++++
 CORE/SERVICES/HIF/ath_procfs.c                     |  14 ++-
 CORE/SERVICES/HIF/hif_oob.c                        |   4 +
 CORE/SERVICES/HIF/sdio/hif_sdio_dev.c              |   6 ++
 CORE/SERVICES/HIF/sdio/hif_sdio_recv.c             |   2 +-
 CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.h         |   4 +-
 CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c |  12 +++
 CORE/SERVICES/HTC/htc_internal.h                   |  19 ----
 CORE/SERVICES/WMA/wma.c                            |   2 -
 CORE/SME/src/QoS/sme_Qos.c                         |   8 +-
 CORE/SME/src/csr/csrApiRoam.c                      |   6 +-
 CORE/SME/src/csr/csrNeighborRoam.c                 |   4 +-
 CORE/SME/src/pmc/pmc.c                             |   1 +
 CORE/SME/src/sme_common/sme_Api.c                  |   2 +-
 CORE/SVC/src/logging/wlan_logging_sock_svc.c       |  26 ++++--
 CORE/UTILS/FWLOG/dbglog_host.c                     |   2 +-
 CORE/UTILS/PKTLOG/linux_ac.c                       |  19 +++-
 CORE/VOSS/inc/vos_cnss.h                           |  19 +++-
 CORE/VOSS/inc/vos_timer.h                          |  18 ++++
 CORE/VOSS/inc/vos_types.h                          |   2 +-
 CORE/VOSS/src/vos_api.c                            |   9 ++
 CORE/VOSS/src/vos_nvitem.c                         |   7 ++
 CORE/VOSS/src/vos_packet.c                         |  12 +--
 CORE/VOSS/src/vos_sched.c                          |   6 ++
 CORE/VOSS/src/vos_timer.c                          | 103 ++++++++++++++++++++-
 CORE/VOSS/src/vos_utils.c                          |   8 +-
 Kbuild                                             |   9 +-
 59 files changed, 659 insertions(+), 90 deletions(-)

diff --git a/CORE/CLD_TXRX/HTT/htt_rx.c b/CORE/CLD_TXRX/HTT/htt_rx.c
index 4ffc6bf..af2a5ca 100644
--- a/CORE/CLD_TXRX/HTT/htt_rx.c
+++ b/CORE/CLD_TXRX/HTT/htt_rx.c
@@ -564,11 +564,13 @@ htt_rx_mpdu_desc_pn_hl(
                 *(word_ptr + 3) = rx_desc->pn_127_96;
                 /* bits 63:0 */
                 *(word_ptr + 2) = rx_desc->pn_95_64;
+                fallthrough;
             case 48:
                 /* bits 48:0
                  * copy 64 bits
                  */
                 *(word_ptr + 1) = rx_desc->u0.pn_63_32;
+                fallthrough;
             case 24:
                 /* bits 23:0
                  * copy 32 bits
diff --git a/CORE/CLD_TXRX/TXRX/ol_rx_defrag.c b/CORE/CLD_TXRX/TXRX/ol_rx_defrag.c
index 014a3a7..a85602f 100644
--- a/CORE/CLD_TXRX/TXRX/ol_rx_defrag.c
+++ b/CORE/CLD_TXRX/TXRX/ol_rx_defrag.c
@@ -62,7 +62,7 @@
 #include <ol_ctrl_txrx_api.h>
 #include <ol_txrx_peer_find.h>
 #include <adf_nbuf.h>
-#include <ieee80211.h>
+#include <linux/ieee80211.h>
 #include <adf_os_util.h>
 #include <athdefs.h>
 #include <adf_os_mem.h>
diff --git a/CORE/CLD_TXRX/TXRX/ol_rx_reorder.c b/CORE/CLD_TXRX/TXRX/ol_rx_reorder.c
index 1fc62d3..55f47d8 100644
--- a/CORE/CLD_TXRX/TXRX/ol_rx_reorder.c
+++ b/CORE/CLD_TXRX/TXRX/ol_rx_reorder.c
@@ -30,7 +30,7 @@
 #include <adf_nbuf.h>          /* adf_nbuf_t, etc. */
 #include <adf_os_mem.h>        /* adf_os_mem_alloc */
 
-#include <ieee80211.h>         /* IEEE80211_SEQ_MAX */
+#include <linux/ieee80211.h>   /* IEEE80211_SEQ_MAX */
 
 /* external interfaces */
 #include <ol_txrx_api.h>       /* ol_txrx_pdev_handle */
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_send.c b/CORE/CLD_TXRX/TXRX/ol_tx_send.c
index 007dfd4..efb5268 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_send.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_send.c
@@ -34,7 +34,7 @@
 
 #include <queue.h>            /* TAILQ */
 #ifdef QCA_COMPUTE_TX_DELAY
-#include <ieee80211.h>        /* ieee80211_frame, etc. */
+#include <linux/ieee80211.h>  /* ieee80211_frame, etc. */
 #include <enet.h>             /* ethernet_hdr_t, etc. */
 #include <ipv6_defs.h>        /* IPV6_TRAFFIC_CLASS */
 #endif
diff --git a/CORE/CLD_TXRX/TXRX/ol_txrx_internal.h b/CORE/CLD_TXRX/TXRX/ol_txrx_internal.h
index 16f9186..73bb08e 100644
--- a/CORE/CLD_TXRX/TXRX/ol_txrx_internal.h
+++ b/CORE/CLD_TXRX/TXRX/ol_txrx_internal.h
@@ -39,7 +39,7 @@
 #include <ol_txrx_dbg.h>
 #include <enet.h>          /* ETHERNET_HDR_LEN, etc. */
 #include <ipv4.h>          /* IPV4_HDR_LEN, etc. */
-#include <ipv6.h>          /* IPV6_HDR_LEN, etc. */
+#include <linux/ipv6.h>          /* IPV6_HDR_LEN, etc. */
 #include <ip_prot.h>       /* IP_PROTOCOL_TCP, etc. */
 
 #ifdef ATH_11AC_TXCOMPACT
diff --git a/CORE/EPPING/src/epping_txrx.c b/CORE/EPPING/src/epping_txrx.c
index d63a4cd..cbfca8c 100644
--- a/CORE/EPPING/src/epping_txrx.c
+++ b/CORE/EPPING/src/epping_txrx.c
@@ -143,7 +143,11 @@ end:
    return;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+void epping_tx_queue_timeout(struct net_device *dev, unsigned int txqueue)
+#else
 void epping_tx_queue_timeout(struct net_device *dev)
+#endif
 {
    epping_adapter_t *pAdapter;
 
@@ -248,7 +252,7 @@ static int epping_set_mac_address(struct net_device *dev, void *addr)
    struct sockaddr *psta_mac_addr = addr;
    vos_mem_copy(&pAdapter->macAddressCurrent,
                 psta_mac_addr->sa_data, ETH_ALEN);
-   vos_mem_copy(dev->dev_addr, psta_mac_addr->sa_data, ETH_ALEN);
+   dev_addr_mod(dev, 0, psta_mac_addr->sa_data, ETH_ALEN);
    return 0;
 }
 
@@ -393,7 +397,7 @@ epping_adapter_t *epping_add_adapter(epping_context_t *pEpping_ctx,
    pAdapter->dev = dev;
    pAdapter->pEpping_ctx = pEpping_ctx;
    pAdapter->device_mode = device_mode; /* station, SAP, etc */
-   vos_mem_copy(dev->dev_addr, (void *)macAddr, sizeof(tSirMacAddr));
+   dev_addr_mod(dev, 0, (void *)macAddr, sizeof(tSirMacAddr));
    vos_mem_copy(pAdapter->macAddressCurrent.bytes,
                 macAddr, sizeof(tSirMacAddr));
    adf_os_spinlock_init(&pAdapter->data_lock);
diff --git a/CORE/HDD/inc/wlan_hdd_ftm.h b/CORE/HDD/inc/wlan_hdd_ftm.h
index ef16756..1cd0dea 100644
--- a/CORE/HDD/inc/wlan_hdd_ftm.h
+++ b/CORE/HDD/inc/wlan_hdd_ftm.h
@@ -30,7 +30,7 @@
 #include "vos_status.h"
 #include "vos_mq.h"
 #include "vos_api.h"
-#include "msg.h"
+#include "linux/msg.h"
 #include "halTypes.h"
 #include "vos_types.h"
 #include <wlan_ptt_sock_svc.h>
diff --git a/CORE/HDD/inc/wlan_hdd_softap_tx_rx.h b/CORE/HDD/inc/wlan_hdd_softap_tx_rx.h
index ba2a5c5..1c352ad 100644
--- a/CORE/HDD/inc/wlan_hdd_softap_tx_rx.h
+++ b/CORE/HDD/inc/wlan_hdd_softap_tx_rx.h
@@ -76,9 +76,14 @@ extern int hdd_softap_hard_start_xmit(struct sk_buff *skb, struct net_device *de
   and returns control to OS right away, this would never be invoked
 
   @param dev : [in] pointer to Libra network device
+  @param txqueue : [in] stucked queue
   @return    : None
   ===========================================================================*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+extern void hdd_softap_tx_timeout(struct net_device *dev, unsigned int txqueue);
+#else
 extern void hdd_softap_tx_timeout(struct net_device *dev);
+#endif
 
 /**============================================================================
   @brief hdd_softap_stats() - Function registered with the Linux OS for
diff --git a/CORE/HDD/inc/wlan_hdd_tx_rx.h b/CORE/HDD/inc/wlan_hdd_tx_rx.h
index 2fd820c..c8e858e 100644
--- a/CORE/HDD/inc/wlan_hdd_tx_rx.h
+++ b/CORE/HDD/inc/wlan_hdd_tx_rx.h
@@ -117,9 +117,14 @@ extern void hdd_drop_skb_list(hdd_adapter_t *adapter, struct sk_buff *skb,
   and returns control to OS right away, this would never be invoked
 
   @param dev : [in] pointer to Libra network device
+  @param txqueue : [in] stucked queue
   @return    : None
   ===========================================================================*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+extern void hdd_tx_timeout(struct net_device *dev, unsigned int txqueue);
+#else
 extern void hdd_tx_timeout(struct net_device *dev);
+#endif
 
 /**============================================================================
   @brief hdd_stats() - Function registered with the Linux OS for
diff --git a/CORE/HDD/src/wlan_hdd_assoc.c b/CORE/HDD/src/wlan_hdd_assoc.c
index 789eefc..3142721 100644
--- a/CORE/HDD/src/wlan_hdd_assoc.c
+++ b/CORE/HDD/src/wlan_hdd_assoc.c
@@ -2147,7 +2147,11 @@ static void hdd_send_roamed_ind(struct net_device *dev,
 {
 	struct cfg80211_roam_info info = {0};
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	info.links[0].bss = bss;
+#else
 	info.bss = bss;
+#endif
 	info.req_ie = req_ie;
 	info.req_ie_len = req_ie_len;
 	info.resp_ie = resp_ie;
@@ -4780,6 +4784,7 @@ hdd_smeRoamCallback(void *pContext, tCsrRoamInfo *pRoamInfo, tANI_U32 roamId,
                     WLAN_CONTROL_PATH);
                 break;
             }
+            fallthrough;
         case eCSR_ROAM_DISASSOCIATED:
             {
                 VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 12552a2..dfd14fb 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -1643,7 +1643,7 @@ static int __is_driver_dfs_capable(struct wiphy *wiphy,
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(3,4,0)) || \
     defined (DFS_MASTER_OFFLOAD_IND_SUPPORT) || defined(WITH_BACKPORTS)
-    dfs_capability = !!(wiphy->flags & WIPHY_FLAG_DFS_OFFLOAD);
+    dfs_capability = !!(wiphy->flags & NL80211_EXT_FEATURE_DFS_OFFLOAD);
 #endif
 
     temp_skbuff = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(u32) +
@@ -5224,7 +5224,11 @@ static int hdd_extscan_passpoint_fill_network_list(
 			hddLog(LOGE, FL("attr realm failed"));
 			return -EINVAL;
 		}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0))
+		len = nla_strscpy(req_msg->networks[index].realm,
+#else
 		len = nla_strlcpy(req_msg->networks[index].realm,
+#endif
 				  network[PARAM_REALM],
 				  SIR_PASSPOINT_REALM_LEN);
 		/* Don't send partial realm to firmware */
@@ -16777,7 +16781,7 @@ int wlan_hdd_cfg80211_init(struct device *dev,
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(3,4,0)) || \
     defined (DFS_MASTER_OFFLOAD_IND_SUPPORT) || defined(WITH_BACKPORTS)
     if (pCfg->enableDFSMasterCap) {
-        wiphy->flags |= WIPHY_FLAG_DFS_OFFLOAD;
+        wiphy->flags |= NL80211_EXT_FEATURE_DFS_OFFLOAD;
     }
 #endif
 
@@ -17536,7 +17540,12 @@ int wlan_hdd_cfg80211_update_apies(hdd_adapter_t* pHostapdAdapter)
                           WLAN_EID_INTERWORKING);
 
     wlan_hdd_add_extra_ie(pHostapdAdapter, genie, &total_ielen,
-                          WLAN_EID_VHT_TX_POWER_ENVELOPE);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0))
+                          WLAN_EID_TX_POWER_ENVELOPE
+#else
+                          WLAN_EID_VHT_TX_POWER_ENVELOPE
+#endif
+                         );
     if (0 != wlan_hdd_add_ie(pHostapdAdapter, genie,
                               &total_ielen, WPS_OUI_TYPE, WPS_OUI_TYPE_SIZE))
     {
@@ -19478,7 +19487,11 @@ static int wlan_hdd_cfg80211_del_beacon(struct wiphy *wiphy,
  * Return: zero for success non-zero for failure
  */
 static int wlan_hdd_cfg80211_stop_ap(struct wiphy *wiphy,
-					struct net_device *dev)
+					struct net_device *dev
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+					, unsigned int link_id
+#endif
+					)
 {
 	int ret;
 
@@ -19505,7 +19518,11 @@ static int wlan_hdd_cfg80211_stop_ap(struct wiphy *wiphy,
  * Return: zero for data rate on success or 0 on failure
  */
 uint16_t hdd_get_data_rate_from_rate_mask(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0))
+		enum nl80211_band band,
+#else
 		enum ieee80211_band band,
+#endif
 		struct cfg80211_bitrate_mask *bit_rate_mask)
 {
 	struct ieee80211_supported_band *sband = wiphy->bands[band];
@@ -19542,7 +19559,11 @@ void hdd_update_beacon_rate(hdd_adapter_t *pAdapter, struct wiphy *wiphy,
 		struct cfg80211_ap_settings *params)
 {
 	struct cfg80211_bitrate_mask *beacon_rate_mask;
-	enum ieee80211_band band;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0))
+		enum nl80211_band band;
+#else
+		enum ieee80211_band band;
+#endif
 
 	band = params->chandef.chan->band;
 	beacon_rate_mask = &params->beacon_rate;
@@ -20856,12 +20877,24 @@ static int __wlan_hdd_change_station(struct wiphy *wiphy,
                 vos_mem_copy(StaParams.extn_capability, params->ext_capab,
                              params->ext_capab_len);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+            if (NULL != params->link_sta_params.ht_capa) {
+#else
             if (NULL != params->ht_capa) {
+#endif
                 StaParams.htcap_present = 1;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                vos_mem_copy(&StaParams.HTCap, params->link_sta_params.ht_capa, sizeof(tSirHTCap));
+#else
                 vos_mem_copy(&StaParams.HTCap, params->ht_capa, sizeof(tSirHTCap));
+#endif
             }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+            StaParams.supported_rates_len = params->link_sta_params.supported_rates_len;
+#else
             StaParams.supported_rates_len = params->supported_rates_len;
+#endif
 
             /*
              * Note : The Maximum sizeof supported_rates sent by the Supplicant
@@ -20877,8 +20910,13 @@ static int __wlan_hdd_change_station(struct wiphy *wiphy,
 
             if (0 != StaParams.supported_rates_len) {
                 int i = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                vos_mem_copy(StaParams.supported_rates, params->link_sta_params.supported_rates,
+                             StaParams.supported_rates_len);
+#else
                 vos_mem_copy(StaParams.supported_rates, params->supported_rates,
                              StaParams.supported_rates_len);
+#endif
                 VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
                            "Supported Rates with Length %d", StaParams.supported_rates_len);
                 for (i=0; i < StaParams.supported_rates_len; i++)
@@ -20886,9 +20924,17 @@ static int __wlan_hdd_change_station(struct wiphy *wiphy,
                                "[%d]: %0x", i, StaParams.supported_rates[i]);
             }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+            if (NULL != params->link_sta_params.vht_capa) {
+#else
             if (NULL != params->vht_capa) {
+#endif
                 StaParams.vhtcap_present = 1;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                vos_mem_copy(&StaParams.VHTCap, params->link_sta_params.vht_capa, sizeof(tSirVHTCap));
+#else
                 vos_mem_copy(&StaParams.VHTCap, params->vht_capa, sizeof(tSirVHTCap));
+#endif
             }
 
             if (0 != params->ext_capab_len ) {
@@ -20903,7 +20949,11 @@ static int __wlan_hdd_change_station(struct wiphy *wiphy,
             }
 
             if (pHddCtx->cfg_ini->fEnableTDLSWmmMode &&
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                (params->link_sta_params.ht_capa || params->link_sta_params.vht_capa ||
+#else
                 (params->ht_capa || params->vht_capa ||
+#endif
                 (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME))))
                 is_qos_wmm_sta = true;
 
@@ -21328,6 +21378,9 @@ static int __wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
 
 static int wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
                                       struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                                      int link_id,
+#endif
                                       u8 key_index, bool pairwise,
                                       const u8 *mac_addr,
                                       struct key_params *params
@@ -21422,6 +21475,9 @@ static int __wlan_hdd_cfg80211_get_key(
 static int wlan_hdd_cfg80211_get_key(
                         struct wiphy *wiphy,
                         struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                        int link_id,
+#endif
                         u8 key_index, bool pairwise,
                         const u8 *mac_addr, void *cookie,
                         void (*callback)(void *cookie, struct key_params*)
@@ -21566,6 +21622,9 @@ static int __wlan_hdd_cfg80211_del_key(struct wiphy *wiphy,
  */
 static int wlan_hdd_cfg80211_del_key(struct wiphy *wiphy,
 					struct net_device *dev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+					int link_id,
+#endif
 					u8 key_index,
 					bool pairwise, const u8 *mac_addr)
 {
@@ -21701,6 +21760,9 @@ static int __wlan_hdd_cfg80211_set_default_key( struct wiphy *wiphy,
 
 static int wlan_hdd_cfg80211_set_default_key( struct wiphy *wiphy,
                                               struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+                                              int link_id,
+#endif
                                               u8 key_index,
                                               bool unicast, bool multicast)
 {
@@ -23131,8 +23193,14 @@ int __wlan_hdd_cfg80211_scan( struct wiphy *wiphy,
 
     if (request->n_channels)
     {
-       char chList [(request->n_channels*5)+1];
+       char *chList;
        int len;
+       chList = vos_mem_malloc((request->n_channels * 5) + 1);
+       if (NULL == chList)
+       {
+          status = -ENOMEM;
+          goto free_mem;
+       }
        channelList = vos_mem_malloc(request->n_channels);
        if (NULL == channelList)
        {
@@ -23153,6 +23221,7 @@ int __wlan_hdd_cfg80211_scan( struct wiphy *wiphy,
 
        hddLog(LOG1, "No of Scan Channels: %d", num_chan);
        hddLog(VOS_TRACE_LEVEL_INFO, "Channel-List: %s", chList);
+       vos_mem_free(chList);
     }
 
     if (!num_chan) {
@@ -25153,7 +25222,15 @@ static int __wlan_hdd_cfg80211_connect( struct wiphy *wiphy,
                             req->bssid, req->ssid,
                             req->ssid_len);
                 if (bss) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0))
+                    struct cfg80211_assoc_failure data;
+                    data.ap_mld_addr = NULL;
+                    data.bss[0] = bss;
+                    data.timeout = true;
+                    cfg80211_assoc_failure(ndev, &data);
+#else
                     cfg80211_assoc_timeout(ndev, bss);
+#endif
                     return -ETIMEDOUT;
                 }
             }
@@ -28015,6 +28092,9 @@ static int __wlan_hdd_set_default_mgmt_key(struct wiphy *wiphy,
  */
 static int wlan_hdd_set_default_mgmt_key(struct wiphy *wiphy,
 					   struct net_device *netdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+					   int link_id,
+#endif
 					   u8 key_index)
 {
 	int ret;
@@ -29139,9 +29219,10 @@ static int __wlan_hdd_cfg80211_sched_scan_start(struct wiphy *wiphy,
     num_ch = 0;
     if (request->n_channels)
     {
-        char chList [(request->n_channels*5)+1];
+        char *chList;
         int len;
-        for (i = 0, len = 0; i < request->n_channels; i++)
+        chList = vos_mem_malloc((request->n_channels * 5) + 1);
+        for (i = 0, len = 0; chList && (i < request->n_channels); i++)
         {
             for (indx = 0; indx < num_channels_allowed; indx++)
             {
@@ -29181,10 +29262,14 @@ static int __wlan_hdd_cfg80211_sched_scan_start(struct wiphy *wiphy,
                  "%s : Channel list empty due to filtering of DSRC,DFS channels",
                  __func__);
              ret = -EINVAL;
+             if (chList)
+                 vos_mem_free(chList);
              goto error;
          }
 
          hddLog(VOS_TRACE_LEVEL_INFO,"Channel-List: %s ", chList);
+         if (chList)
+             vos_mem_free(chList);
     }
 
     /* Filling per profile  params */
diff --git a/CORE/HDD/src/wlan_hdd_hostapd.c b/CORE/HDD/src/wlan_hdd_hostapd.c
index 60a6387..ffa2144 100644
--- a/CORE/HDD/src/wlan_hdd_hostapd.c
+++ b/CORE/HDD/src/wlan_hdd_hostapd.c
@@ -1051,7 +1051,7 @@ static int __hdd_hostapd_set_mac_address(struct net_device *dev, void *addr)
    if (0 != ret)
        return ret;
 
-   memcpy(dev->dev_addr, psta_mac_addr->sa_data, ETH_ALEN);
+   dev_addr_mod(dev, 0, psta_mac_addr->sa_data, ETH_ALEN);
    EXIT();
    return 0;
 }
@@ -1551,7 +1551,13 @@ VOS_STATUS hdd_chan_change_notify(hdd_adapter_t *hostapd_adapter,
 	    (phy_mode == eCSR_DOT11_MODE_11ac_ONLY))
 		hdd_update_chandef(hostapd_adapter, &chandef, cb_mode);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0))
+	cfg80211_ch_switch_notify(dev, &chandef, 0, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0))
+	cfg80211_ch_switch_notify(dev, &chandef, 0);
+#else
 	cfg80211_ch_switch_notify(dev, &chandef);
+#endif
 
 	return VOS_STATUS_SUCCESS;
 }
@@ -8591,7 +8597,7 @@ hdd_adapter_t* hdd_wlan_create_ap_dev(hdd_context_t *pHddCtx,
         pWlanHostapdDev->mtu = HDD_DEFAULT_MTU;
         pWlanHostapdDev->tx_queue_len = HDD_NETDEV_TX_QUEUE_LEN;
 
-        vos_mem_copy(pWlanHostapdDev->dev_addr, (void *)macAddr,sizeof(tSirMacAddr));
+        dev_addr_mod(pWlanHostapdDev, 0, macAddr, ETH_ALEN);
         vos_mem_copy(pHostapdAdapter->macAddressCurrent.bytes, (void *)macAddr, sizeof(tSirMacAddr));
 
         pHostapdAdapter->offloads_configured = FALSE;
diff --git a/CORE/HDD/src/wlan_hdd_main.c b/CORE/HDD/src/wlan_hdd_main.c
index fd1cb23..038f774 100644
--- a/CORE/HDD/src/wlan_hdd_main.c
+++ b/CORE/HDD/src/wlan_hdd_main.c
@@ -8705,6 +8705,14 @@ static int hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	return ret;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0))
+static int hdd_siocdevprivate(struct net_device *dev, struct ifreq *ifr, void
+			      __user *data, int cmd)
+{
+	// data and ifr->ifr_data are one and the same. call hdd_ioctl
+	return hdd_ioctl(dev, ifr, cmd);
+}
+#endif
 
 /*
  * Mac address for multiple virtual interface is found as following
@@ -10757,7 +10765,7 @@ static int __hdd_set_mac_address(struct net_device *dev, void *addr)
 		return ret;
 
 	memcpy(&pAdapter->macAddressCurrent, psta_mac_addr->sa_data, ETH_ALEN);
-	memcpy(dev->dev_addr, psta_mac_addr->sa_data, ETH_ALEN);
+	dev_addr_mod(dev, 0, psta_mac_addr->sa_data, ETH_ALEN);
 
 	EXIT();
 	return 0;
@@ -10977,6 +10985,9 @@ static struct net_device_ops wlan_drv_ops = {
       .ndo_tx_timeout = hdd_tx_timeout,
       .ndo_get_stats = hdd_stats,
       .ndo_do_ioctl = hdd_ioctl,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0))
+      .ndo_siocdevprivate = hdd_siocdevprivate,
+#endif
       .ndo_set_mac_address = hdd_set_mac_address,
       .ndo_select_queue    = hdd_select_queue,
 #ifdef WLAN_FEATURE_PACKET_FILTERING
@@ -11224,7 +11235,7 @@ static hdd_adapter_t* hdd_alloc_station_adapter(hdd_context_t *pHddCtx,
       strlcpy(pAdapter->ifname, name, IFNAMSIZ);
 #endif
 
-      vos_mem_copy(pWlanDev->dev_addr, (void *)macAddr, sizeof(tSirMacAddr));
+      dev_addr_mod(pWlanDev, 0, (void *)macAddr, sizeof(tSirMacAddr));
       vos_mem_copy( pAdapter->macAddressCurrent.bytes, macAddr, sizeof(tSirMacAddr));
       pWlanDev->watchdog_timeo = HDD_TX_TIMEOUT;
       /*
@@ -11295,8 +11306,7 @@ static hdd_adapter_t *hdd_alloc_monitor_adapter(hdd_context_t *pHddCtx,
 	   /* Init the net_device structure */
 	   strlcpy(pwlan_dev->name, name, IFNAMSIZ);
 
-	   vos_mem_copy(pwlan_dev->dev_addr,
-			(void *)macAddr, sizeof(tSirMacAddr));
+	   dev_addr_mod(pwlan_dev, 0, (void *)macAddr, sizeof(tSirMacAddr));
 	   vos_mem_copy(pAdapter->macAddressCurrent.bytes,
 			macAddr, sizeof(tSirMacAddr));
 	   pwlan_dev->watchdog_timeo = HDD_TX_TIMEOUT;
@@ -11344,7 +11354,11 @@ VOS_STATUS hdd_register_interface( hdd_adapter_t *pAdapter, tANI_U8 rtnl_lock_he
             return VOS_STATUS_E_FAILURE;
          }
       }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+      if (cfg80211_register_netdevice(pWlanDev))
+#else
       if (register_netdevice(pWlanDev))
+#endif
       {
          hddLog(VOS_TRACE_LEVEL_ERROR,"%s:Failed:register_netdev",__func__);
          return VOS_STATUS_E_FAILURE;
@@ -11726,7 +11740,11 @@ void hdd_cleanup_adapter(hdd_context_t *pHddCtx, hdd_adapter_t *pAdapter,
 
    if (test_bit(NET_DEVICE_REGISTERED, &pAdapter->event_flags)) {
       if (rtnl_held) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+         cfg80211_unregister_netdevice(pWlanDev);
+#else
          unregister_netdevice(pWlanDev);
+#endif
       } else {
          unregister_netdev(pWlanDev);
       }
@@ -12109,7 +12127,7 @@ hdd_adapter_t *hdd_open_adapter(hdd_context_t *hdd_ctx,
 	case WLAN_HDD_INFRA_STATION:
 		 /* Reset locally administered bit if the device mode is STA */
 		WLAN_HDD_RESET_LOCALLY_ADMINISTERED_BIT(mac_addr);
-	/* fall through */
+	fallthrough;
 	case WLAN_HDD_P2P_CLIENT:
 	case WLAN_HDD_P2P_DEVICE:
 	case WLAN_HDD_OCB:
@@ -12591,7 +12609,11 @@ err_add_adapter_back:
 
 err_malloc_adapter_node:
 	if (rtnl_held)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+		cfg80211_unregister_netdevice(adapter->dev);
+#else
 		unregister_netdevice(adapter->dev);
+#endif
 	else
 		unregister_netdev(adapter->dev);
 
@@ -13333,8 +13355,11 @@ static void hdd_connect_bss(struct net_device *dev, const u8 *bssid,
 #endif
 
 #ifdef WLAN_FEATURE_FILS_SK
-#ifdef CFG80211_CONNECT_DONE
-#ifdef CFG80211_FILS_SK_OFFLOAD_SUPPORT
+#if (defined(CFG80211_CONNECT_DONE) || \
+	(LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))) && \
+	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0))
+#if defined(CFG80211_FILS_SK_OFFLOAD_SUPPORT) || \
+		 (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 /**
  * hdd_populate_fils_params() - Populate FILS keys to connect response
  * @fils_params: connect response to supplicant
@@ -15778,7 +15803,9 @@ static void hdd_set_ixc_prio(void *priv)
     struct pid* pid;
     struct task_struct* task;
     char comm[16];
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0))
     struct sched_param param = {.sched_priority = 99};
+#endif
     hdd_context_t *pHddCtx = (hdd_context_t *)priv;
 
     if(pHddCtx->ixc_pid != 0) {
@@ -15805,7 +15832,12 @@ static void hdd_set_ixc_prio(void *priv)
                 memset(comm, 0, sizeof(comm));
                 strcpy(comm, task->comm);
                 if(strstr(comm, "ixchariot") || strstr(comm, "iperf")) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0))
+                    sched_set_fifo(task);
+#else
                     sched_setscheduler(task, SCHED_FIFO, &param);
+#endif
+
 #ifdef CONFIG_PERF_MODE
                     enable_wlan_perf_mode();
 #endif
@@ -15880,8 +15912,13 @@ void hdd_cnss_request_bus_bandwidth(hdd_context_t *pHddCtx,
                 hddLog(LOGE, FL("low bandwidth set rx affinity fail"));
         } else {
             if (!pHddCtx->hbw_requested) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
+                vos_request_pm_qos_type(PM_QOS_DEFAULT_VALUE,
+                                      DISABLE_KRAIT_IDLE_PS_VAL);
+#else
                 vos_request_pm_qos_type(PM_QOS_CPU_DMA_LATENCY,
                                       DISABLE_KRAIT_IDLE_PS_VAL);
+#endif
                 pHddCtx->hbw_requested = true;
             }
             if (vos_sched_handle_throughput_req(true))
@@ -18414,8 +18451,11 @@ static int hdd_driver_init( void)
     * huge during driver load. So prevent APPS IDLE/SA PS during driver
     * load for reducing interrupt latency.
     */
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
+   vos_request_pm_qos_type(PM_QOS_DEFAULT_VALUE, DISABLE_KRAIT_IDLE_PS_VAL);
+#else
    vos_request_pm_qos_type(PM_QOS_CPU_DMA_LATENCY, DISABLE_KRAIT_IDLE_PS_VAL);
+#endif
 
    vos_ssr_protect_init();
 
diff --git a/CORE/HDD/src/wlan_hdd_memdump.c b/CORE/HDD/src/wlan_hdd_memdump.c
index 09deb2e..d2ecd1d 100644
--- a/CORE/HDD/src/wlan_hdd_memdump.c
+++ b/CORE/HDD/src/wlan_hdd_memdump.c
@@ -203,7 +203,18 @@ static ssize_t hdd_driver_memdump_read(struct file *file, char __user *buf,
 	return no_of_bytes_read;
 }
 
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+/**
+ * struct driver_dump_fops - file operations for driver dump feature
+ * @proc_read - read function for driver dump operation.
+ *
+ * This structure initialize the file operation handle for memory
+ * dump feature
+ */
+static const struct proc_ops driver_dump_proc_ops = {
+	.proc_read = hdd_driver_memdump_read,
+};
+#else
 /**
  * struct driver_dump_fops - file operations for driver dump feature
  * @read - read function for driver dump operation.
@@ -214,6 +225,7 @@ static ssize_t hdd_driver_memdump_read(struct file *file, char __user *buf,
 static const struct file_operations driver_dump_fops = {
 	read: hdd_driver_memdump_read
 };
+#endif
 
 /**
  * hdd_driver_memdump_procfs_init() - Initialize procfs for driver memory dump
@@ -232,10 +244,15 @@ static int hdd_driver_memdump_procfs_init(hdd_context_t *hdd_ctx)
 			 PROCFS_DRIVER_DUMP_DIR);
 		return -ENOMEM;
 	}
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+	proc_file_driver = proc_create_data(PROCFS_DRIVER_DUMP_NAME,
+				     PROCFS_DRIVER_DUMP_PERM, proc_dir_driver,
+				     &driver_dump_proc_ops, hdd_ctx);
+#else
 	proc_file_driver = proc_create_data(PROCFS_DRIVER_DUMP_NAME,
 				     PROCFS_DRIVER_DUMP_PERM, proc_dir_driver,
 				     &driver_dump_fops, hdd_ctx);
+#endif
 	if (proc_file_driver == NULL) {
 		remove_proc_entry(PROCFS_DRIVER_DUMP_NAME, proc_dir_driver);
 		pr_debug("Error: Could not initialize /proc/%s\n",
diff --git a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
index 40ce8fd..3379209 100644
--- a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
@@ -555,10 +555,15 @@ static void __hdd_softap_tx_timeout(struct net_device *dev)
 /**
  * hdd_softap_tx_timeout() - SSR wrapper for __hdd_softap_tx_timeout
  * @dev: pointer to net_device
+ * @txqueue: stucked queue
  *
  * Return: none
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+void hdd_softap_tx_timeout(struct net_device *dev, unsigned int txqueue)
+#else
 void hdd_softap_tx_timeout(struct net_device *dev)
+#endif
 {
 	vos_ssr_protect(__func__);
 	__hdd_softap_tx_timeout(dev);
diff --git a/CORE/HDD/src/wlan_hdd_tx_rx.c b/CORE/HDD/src/wlan_hdd_tx_rx.c
index 165467e..63ff2da 100644
--- a/CORE/HDD/src/wlan_hdd_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_tx_rx.c
@@ -920,6 +920,7 @@ static void __hdd_tx_timeout(struct net_device *dev)
 /**
  * hdd_tx_timeout() - Wrapper function to protect __hdd_tx_timeout from SSR
  * @dev: pointer to net_device structure
+ * @txqueue: stucked queue
  *
  * Function called by OS if there is any timeout during transmission.
  * Since HDD simply enqueues packet and returns control to OS right away,
@@ -927,7 +928,11 @@ static void __hdd_tx_timeout(struct net_device *dev)
  *
  * Return: none
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+void hdd_tx_timeout(struct net_device *dev, unsigned int txqueue)
+#else
 void hdd_tx_timeout(struct net_device *dev)
+#endif
 {
 	vos_ssr_protect(__func__);
 	__hdd_tx_timeout(dev);
diff --git a/CORE/HDD/src/wlan_hdd_wext.c b/CORE/HDD/src/wlan_hdd_wext.c
index 9d84f06..9cf5527 100644
--- a/CORE/HDD/src/wlan_hdd_wext.c
+++ b/CORE/HDD/src/wlan_hdd_wext.c
@@ -9928,6 +9928,7 @@ static int __iw_set_host_offload(struct net_device *dev,
                     break;
                 case WLAN_OFFLOAD_ARP_AND_BC_FILTER_ENABLE:
                     hddLog(VOS_TRACE_LEVEL_WARN, "   BC Filtering enable");
+                    fallthrough;
                 case WLAN_OFFLOAD_ENABLE:
                     hddLog(VOS_TRACE_LEVEL_WARN, "   ARP offload enable");
                     hddLog(VOS_TRACE_LEVEL_WARN, "   IP address: %d.%d.%d.%d",
diff --git a/CORE/HDD/src/wlan_hdd_wmm.c b/CORE/HDD/src/wlan_hdd_wmm.c
index 023b628..74036a7 100644
--- a/CORE/HDD/src/wlan_hdd_wmm.c
+++ b/CORE/HDD/src/wlan_hdd_wmm.c
@@ -1439,6 +1439,7 @@ static void __hdd_wmm_do_implicit_qos(struct work_struct *work)
       // in either case SME won't ever reference this context so
       // free the record
       hdd_wmm_free_context(pQosContext);
+      fallthrough;
 
       // fall through and start packets flowing
    case SME_QOS_STATUS_SETUP_SUCCESS_NO_ACM_NO_APSD_RSP:
diff --git a/CORE/MAC/inc/qwlan_version.h b/CORE/MAC/inc/qwlan_version.h
index aefb634..f78e57c 100644
--- a/CORE/MAC/inc/qwlan_version.h
+++ b/CORE/MAC/inc/qwlan_version.h
@@ -44,7 +44,7 @@ BRIEF DESCRIPTION:
 #define QWLAN_VERSION_EXTRA            ""
 #define QWLAN_VERSION_BUILD            38
 
-#define QWLAN_VERSIONSTR               "4.5.25.38"
+#define QWLAN_VERSIONSTR               "4.5.25.38-plain"
 
 
 #define AR6320_REV1_VERSION             0x5000000
diff --git a/CORE/MAC/src/cfg/cfgProcMsg.c b/CORE/MAC/src/cfg/cfgProcMsg.c
index eee2d4e..23d1d47 100644
--- a/CORE/MAC/src/cfg/cfgProcMsg.c
+++ b/CORE/MAC/src/cfg/cfgProcMsg.c
@@ -1986,7 +1986,7 @@ struct cgstatic cfg_static[WNI_CFG_MAX] = {
 	 WNI_CFG_MASK_LEGACY_RATE_STAMIN,
 	 WNI_CFG_MASK_LEGACY_RATE_STAMAX,
 	 WNI_CFG_MASK_LEGACY_RATE_STADEF},
-	 
+
 	{WNI_CFG_MASK_TX_HT_RATE,
 	 CFG_CTL_VALID | CFG_CTL_RE | CFG_CTL_WE | CFG_CTL_INT,
 	 WNI_CFG_MASK_HT_RATE_STAMIN,
diff --git a/CORE/MAC/src/include/parserApi.h b/CORE/MAC/src/include/parserApi.h
index 158ed57..c2fc46d 100644
--- a/CORE/MAC/src/include/parserApi.h
+++ b/CORE/MAC/src/include/parserApi.h
@@ -1082,8 +1082,8 @@ tSirRetStatus PopulateDot11fRRMIe( tpAniSirGlobal pMac,
 #endif
 
 #if defined WLAN_FEATURE_VOWIFI_11R
-void PopulateMDIE( tpAniSirGlobal        pMac,
-                   tDot11fIEMobilityDomain *pDot11f, tANI_U8 mdie[] );
+void PopulateMDIE( tpAniSirGlobal pMac, tDot11fIEMobilityDomain *pDot11f,
+                   tANI_U8 mdie[SIR_MDIE_SIZE] );
 void PopulateFTInfo( tpAniSirGlobal      pMac,
                      tDot11fIEFTInfo     *pDot11f );
 #endif
diff --git a/CORE/MAC/src/pe/lim/limProcessCfgUpdates.c b/CORE/MAC/src/pe/lim/limProcessCfgUpdates.c
index 9639d21..f5061b4 100644
--- a/CORE/MAC/src/pe/lim/limProcessCfgUpdates.c
+++ b/CORE/MAC/src/pe/lim/limProcessCfgUpdates.c
@@ -490,6 +490,7 @@ limHandleCFGparamUpdate(tpAniSirGlobal pMac, tANI_U32 cfgId)
                 }
             }
         }
+        fallthrough;
     case WNI_CFG_MAX_PS_POLL:
     case WNI_CFG_NUM_BEACON_PER_RSSI_AVERAGE:
     case WNI_CFG_MIN_RSSI_THRESHOLD:
diff --git a/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c b/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
index 4091477..7b296b3 100644
--- a/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
+++ b/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
@@ -6239,6 +6239,7 @@ limProcessSmeReqMessages(tpAniSirGlobal pMac, tpSirMsgQ pMsg)
             /*
              * Do not add BREAK here
              */
+            fallthrough;
 #ifdef FEATURE_OEM_DATA_SUPPORT
         case eWNI_SME_OEM_DATA_REQ:
 #endif
diff --git a/CORE/SAP/src/sapFsm.c b/CORE/SAP/src/sapFsm.c
index a396a6b..7402c57 100644
--- a/CORE/SAP/src/sapFsm.c
+++ b/CORE/SAP/src/sapFsm.c
@@ -3133,8 +3133,8 @@ sapGotoStarting
     if (eHAL_STATUS_SUCCESS != halStatus)
         VOS_TRACE(VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_ERROR,
         "%s: Failed to issue sme_RoamConnect", __func__);
-        return halStatus;
 
+    return halStatus;
 }// sapGotoStarting
 
 /*==========================================================================
diff --git a/CORE/SAP/src/sapModule.c b/CORE/SAP/src/sapModule.c
index 97b779c..bc2aa00 100644
--- a/CORE/SAP/src/sapModule.c
+++ b/CORE/SAP/src/sapModule.c
@@ -3832,18 +3832,21 @@ WLANSAP_ResetSapConfigAddIE(tsap_Config_t *pConfig,
         pConfig->probeRespIEsBufferLen = 0;
         pConfig->pProbeRespIEsBuffer = NULL;
         if(eUPDATE_IE_ALL != updateType)  break;
+        fallthrough;
 
     case eUPDATE_IE_ASSOC_RESP:
         vos_mem_free( pConfig->pAssocRespIEsBuffer);
         pConfig->assocRespIEsLen = 0;
         pConfig->pAssocRespIEsBuffer = NULL;
         if(eUPDATE_IE_ALL != updateType)  break;
+        fallthrough;
 
     case eUPDATE_IE_PROBE_BCN:
         vos_mem_free(pConfig->pProbeRespBcnIEsBuffer );
         pConfig->probeRespBcnIEsLen = 0;
         pConfig->pProbeRespBcnIEsBuffer = NULL;
         if(eUPDATE_IE_ALL != updateType)  break;
+        fallthrough;
 
     default:
         if(eUPDATE_IE_ALL != updateType)
diff --git a/CORE/SERVICES/BMI/ol_fw.c b/CORE/SERVICES/BMI/ol_fw.c
index f87eaf6..d8043d0 100644
--- a/CORE/SERVICES/BMI/ol_fw.c
+++ b/CORE/SERVICES/BMI/ol_fw.c
@@ -453,6 +453,18 @@ static ssize_t crash_dump_read(struct file *file, char __user *buf,
 #endif
 	return no_of_bytes_read;
 }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+/**
+ * struct crash_dump_proc_ops - file operations for crash firmware ram dump feature
+ * @proc_read - read function for crash dump operation.
+ *
+ * This structure initialize the file operation handle for crash
+ * dump feature
+ */
+static const struct proc_ops crash_dump_proc_ops = {
+	.proc_read = crash_dump_read,
+};
+#else
 /**
  * struct crash_dump_fops - file operations for crash firmware ram dump feature
  * @read - read function for crash dump operation.
@@ -463,6 +475,7 @@ static ssize_t crash_dump_read(struct file *file, char __user *buf,
 static const struct file_operations crash_dump_fops = {
 	read: crash_dump_read
 };
+#endif
 
 /**
  * crash_dump_procfs_remove() - Remove file/dir under procfs for crash dump
@@ -506,11 +519,18 @@ static int crash_dump_procfs_init(struct ol_softc *scn)
 			 PROCFS_CRASH_DUMP_DIR);
 		return -ENOMEM;
 	}
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+	crash_file = proc_create_data(PROCFS_CRASH_DUMP_NAME,
+				     PROCFS_CRASH_DUMP_PERM,
+				     crash_dir,
+				     &crash_dump_proc_ops, scn);
+#else
 	crash_file = proc_create_data(PROCFS_CRASH_DUMP_NAME,
 				     PROCFS_CRASH_DUMP_PERM,
 				     crash_dir,
 				     &crash_dump_fops, scn);
+
+#endif
 	if (crash_file == NULL) {
 		crash_dump_procfs_remove();
 		pr_debug("Error: Could not initialize /proc/debug/%s\n",
@@ -1500,9 +1520,13 @@ int ol_copy_ramdump(struct ol_softc *scn)
 		ret = -EACCES;
 		goto out;
 	}
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
+	vos_request_pm_qos_type(PM_QOS_DEFAULT_VALUE,
+				DISABLE_KRAIT_IDLE_PS_VAL);
+#else
 	vos_request_pm_qos_type(PM_QOS_CPU_DMA_LATENCY,
 				DISABLE_KRAIT_IDLE_PS_VAL);
+#endif
 	ret = ol_target_coredump(scn, scn->ramdump_base, scn->ramdump_size);
 	vos_remove_pm_qos();
 
@@ -2341,6 +2365,7 @@ A_STATUS ol_fw_populate_clk_settings(A_refclk_speed_t refclk,
 		clock_s->wlan_pll.outdiv = 0;
 		clock_s->pll_settling_time = 1024;
 		clock_s->refclk_hz = 0;
+		fallthrough;
 	default:
 		return A_ERROR;
 	}
@@ -3332,12 +3357,14 @@ int ol_target_coredump(void *inst, void *memoryBlock, u_int32_t blockLength)
 	uint32_t sectionCount = 0;
 	uint32_t pos = 0;
 	uint32_t readLen = 0;
+#ifdef FW_RAM_DUMP_TO_FILE
 	char fw_dump_filename[40];
 
 #ifdef CONFIG_NON_QC_PLATFORM_PCI
 	char *fw_ram_seg_name[] = {"DRAM ", "AXI ", "REG ", "IRAM1 ", "IRAM2 "};
 #else
 	char *fw_ram_seg_name[] = {"DRAM", "AXI", "REG", "IRAM"};
+#endif
 #endif
 
 	if (scn->fastfwdump_host && scn->fastfwdump_fw) {
diff --git a/CORE/SERVICES/COMMON/adf/adf_nbuf.c b/CORE/SERVICES/COMMON/adf/adf_nbuf.c
index e2c4728..e8faba2 100644
--- a/CORE/SERVICES/COMMON/adf/adf_nbuf.c
+++ b/CORE/SERVICES/COMMON/adf/adf_nbuf.c
@@ -2444,8 +2444,13 @@ __adf_nbuf_validate_skb_cb(void)
 	 * Add compile time assert if SKB control block is exceeding
 	 * 48 byte.
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0))
+	BUILD_BUG_ON(sizeof(struct cvg_nbuf_cb) >
+		sizeof_field(struct sk_buff, cb));
+#else
 	BUILD_BUG_ON(sizeof(struct cvg_nbuf_cb) >
 		FIELD_SIZEOF(struct sk_buff, cb));
+#endif
 }
 
 /**
diff --git a/CORE/SERVICES/COMMON/adf/adf_os_dma.h b/CORE/SERVICES/COMMON/adf/adf_os_dma.h
index f18bcde..90efeda 100644
--- a/CORE/SERVICES/COMMON/adf/adf_os_dma.h
+++ b/CORE/SERVICES/COMMON/adf/adf_os_dma.h
@@ -49,9 +49,21 @@
  * @param[in]  size      DMA buffer size
  * @param[in]  coherent  0 => cached.
  * @param[out] dmap      opaque coherent memory handle
+ * @param[in]  dir       DMA memory access direction for non-coherent
  *
  * @return     returns the virtual address of the memory
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
+static inline void *
+adf_os_dmamem_alloc(adf_os_device_t     osdev,
+                    adf_os_size_t       size,
+                    a_bool_t            coherent,
+                    adf_os_dma_map_t   *dmap,
+                    adf_os_dma_dir_t    dir)
+{
+    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap, dir);
+}
+#else
 static inline void *
 adf_os_dmamem_alloc(adf_os_device_t     osdev,
                     adf_os_size_t       size,
@@ -60,6 +72,7 @@ adf_os_dmamem_alloc(adf_os_device_t     osdev,
 {
     return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
 }
+#endif
 
 /**
  * @brief Free a previously mapped DMA buffer
@@ -69,7 +82,20 @@ adf_os_dmamem_alloc(adf_os_device_t     osdev,
  * @param[in] coherent  0 => cached.
  * @param[in] vaddr     virtual address of DMA buffer
  * @param[in] dmap      memory handle
+ * @param[in] dir       DMA memory access direction for non-coherent
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
+static inline void
+adf_os_dmamem_free(adf_os_device_t    osdev,
+                   adf_os_size_t      size,
+                   a_bool_t           coherent,
+                   void              *vaddr,
+                   adf_os_dma_map_t   dmap,
+                   adf_os_dma_dir_t   dir)
+{
+    __adf_os_dmamem_free(osdev, size, coherent, vaddr, dmap, dir);
+}
+#else
 static inline void
 adf_os_dmamem_free(adf_os_device_t    osdev,
                    adf_os_size_t      size,
@@ -80,6 +106,8 @@ adf_os_dmamem_free(adf_os_device_t    osdev,
     __adf_os_dmamem_free(osdev, size, coherent, vaddr, dmap);
 }
 
+
+#endif
 /**
  * @brief given a dmamem map, returns the (bus) address
  *
diff --git a/CORE/SERVICES/COMMON/adf/adf_os_time.h b/CORE/SERVICES/COMMON/adf/adf_os_time.h
index 6c92692..9cd53b2 100644
--- a/CORE/SERVICES/COMMON/adf/adf_os_time.h
+++ b/CORE/SERVICES/COMMON/adf/adf_os_time.h
@@ -149,7 +149,11 @@ adf_os_msleep(int msecs)
 static inline a_uint64_t adf_get_boottime(void)
 {
 #ifdef CONFIG_CNSS
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0))
+   struct timespec64 ts;
+#else
    struct timespec ts;
+#endif
 
    vos_get_boottime_ts(&ts);
 
diff --git a/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h b/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h
index 6a5bcda..e259fa0 100644
--- a/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h
+++ b/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h
@@ -42,7 +42,10 @@
 #include <adf_os_types.h>
 #include <adf_os_util.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
+#define __adf_os_dma_alloc_noncoherent(dev, size, daddr, dir, flag) dma_alloc_noncoherent(dev, size, daddr, dir, flag)
+#define __adf_os_dma_free_noncoherent(dev, size, vddr, daddr, dir) dma_free_noncoherent(dev, size, vddr, daddr, dir)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
 #define __adf_os_dma_alloc_noncoherent(dev, size, daddr, flag, attr) dma_alloc_attrs(dev, size, daddr, flag, attr)
 #define __adf_os_dma_free_noncoherent(dev, size, vddr, daddr, attr) dma_free_attrs(dev, size, vddr, daddr, attr)
 #else
@@ -61,6 +64,42 @@
  *
  * @return void*
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
+static inline void *
+__adf_os_dmamem_alloc(adf_os_device_t     osdev,
+                      size_t       size,
+                      a_bool_t            coherent,
+                      __adf_os_dma_map_t   *dmap,
+                      adf_os_dma_dir_t     dir)
+{
+    void               *vaddr;
+    __adf_os_dma_map_t  lmap;
+
+   lmap = kzalloc(sizeof(struct __adf_os_dma_map), GFP_KERNEL);
+
+   adf_os_assert(lmap);
+
+   lmap->nsegs = 1;
+   lmap->coherent = coherent;
+
+   if(coherent)
+       vaddr = dma_alloc_coherent(osdev->dev, size, &lmap->seg[0].daddr,
+                                  GFP_ATOMIC);
+   else
+       vaddr = __adf_os_dma_alloc_noncoherent(osdev->dev, size,
+                                     &lmap->seg[0].daddr,
+                                     dir, GFP_ATOMIC);
+
+   adf_os_assert(vaddr);
+
+   lmap->seg[0].len = size;
+   lmap->mapped = 1;
+
+   (*dmap) = lmap;
+
+   return vaddr;
+}
+#else
 static inline void *
 __adf_os_dmamem_alloc(adf_os_device_t     osdev,
                       size_t       size,
@@ -94,12 +133,31 @@ __adf_os_dmamem_alloc(adf_os_device_t     osdev,
 
    return vaddr;
 }
+#endif
 
 /*
  * Free a previously mapped DMA buffer
  * Direction doesnt matter, since this API is called at closing time.
  */
 static inline void
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
+__adf_os_dmamem_free(adf_os_device_t    osdev, __adf_os_size_t size,
+                     a_bool_t coherent, void *vaddr, __adf_os_dma_map_t dmap,
+                     adf_os_dma_dir_t dir)
+{
+    adf_os_assert(dmap->mapped);
+
+    if(coherent)
+        dma_free_coherent(osdev->dev, size, vaddr, dmap->seg[0].daddr);
+    else
+        __adf_os_dma_free_noncoherent(osdev->dev, size, vaddr,
+                                      dmap->seg[0].daddr,
+                                      dir);
+
+    kfree(dmap);
+}
+#else
+static inline void
 __adf_os_dmamem_free(adf_os_device_t    osdev, __adf_os_size_t size,
                      a_bool_t coherent, void *vaddr, __adf_os_dma_map_t dmap)
 {
@@ -114,7 +172,7 @@ __adf_os_dmamem_free(adf_os_device_t    osdev, __adf_os_size_t size,
 
     kfree(dmap);
 }
-
+#endif
 
 #define __adf_os_dmamem_map2addr(_dmap)    ((_dmap)->seg[0].daddr)
 
diff --git a/CORE/SERVICES/COMMON/adf/linux/qdf_crypto.c b/CORE/SERVICES/COMMON/adf/linux/qdf_crypto.c
index 4408883..6dfe28e 100644
--- a/CORE/SERVICES/COMMON/adf/linux/qdf_crypto.c
+++ b/CORE/SERVICES/COMMON/adf/linux/qdf_crypto.c
@@ -68,11 +68,12 @@ int qdf_get_hash(uint8_t *type,
     int ret = 0,i;
     struct {
         struct shash_desc shash;
-        char ctx[crypto_shash_descsize(tfm)];
     } desc;
 
     desc.shash.tfm = tfm;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0))
     desc.shash.flags = 0;
+#endif
     ret = crypto_shash_init(&desc.shash);
     if (ret)
         goto fail;
@@ -101,11 +102,12 @@ int qdf_get_hmac_hash(uint8_t *type, uint8_t *key,
     int ret,i;
     struct {
         struct shash_desc shash;
-        char ctx[crypto_shash_descsize(tfm)];
     } desc;
 
     desc.shash.tfm = tfm;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0))
     desc.shash.flags = 0;
+#endif
     ret = crypto_shash_setkey(desc.shash.tfm, key, keylen);
     if (ret)
         goto fail;
@@ -175,7 +177,9 @@ int qdf_get_keyed_hash(const char *alg, const uint8_t *key,
     do {
         SHASH_DESC_ON_STACK(desc, tfm);
         desc->tfm = tfm;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0))
         desc->flags = crypto_shash_get_flags(tfm);
+#endif
 
         ret = crypto_shash_init(desc);
         if (ret) {
diff --git a/CORE/SERVICES/COMMON/adf/qdf_crypto.h b/CORE/SERVICES/COMMON/adf/qdf_crypto.h
index 617ccb0..86b0964 100644
--- a/CORE/SERVICES/COMMON/adf/qdf_crypto.h
+++ b/CORE/SERVICES/COMMON/adf/qdf_crypto.h
@@ -30,7 +30,11 @@
 #include <crypto/hash.h>
 #include <crypto/aes.h>
 #include <crypto/skcipher.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0))
+#include <crypto/sha1.h>
+#else
 #include <crypto/sha.h>
+#endif
 
 /* Preprocessor definitions and constants */
 
diff --git a/CORE/SERVICES/COMMON/osapi_linux.h b/CORE/SERVICES/COMMON/osapi_linux.h
index cb7b3ac..2a5e626 100644
--- a/CORE/SERVICES/COMMON/osapi_linux.h
+++ b/CORE/SERVICES/COMMON/osapi_linux.h
@@ -436,6 +436,39 @@ bool A_SEMA_SLEEP(void *osdev, A_SEMA *sem)
 typedef struct ieee80211_cb wbuf_context;
 #define wbuf_get_cb(skb)   ((skb)->cb)
 
+#ifndef fallthrough
+#if __has_attribute(__fallthrough__)
+# define fallthrough                    __attribute__((__fallthrough__))
+#else
+# define fallthrough                    do {} while (0)  /* fallthrough */
+#endif
+#endif /* !defined fallthrough */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+#define complete_and_exit	kthread_complete_and_exit
+#define PDE_DATA		pde_data
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,18,0))
+#define netif_rx_ni(skb)	netif_rx(skb)
+#endif
+/**
+ * FIELD_SIZEOF - get the size of a struct's field
+ * @t: the target struct
+ * @f: the target struct's field
+ * Return: the size of @f in the struct definition without having a
+ * declared instance of @t.
+ */
+#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 188))
+static inline void dev_addr_mod(struct net_device *dev, unsigned int offset,
+		  const void *addr, size_t len)
+{
+	memcpy(dev->dev_addr, addr, len);
+}
+#endif
+
 #else /* __KERNEL__ */
 
 #ifdef __GNUC__
diff --git a/CORE/SERVICES/HIF/ath_procfs.c b/CORE/SERVICES/HIF/ath_procfs.c
index 66c7374..69443ff 100644
--- a/CORE/SERVICES/HIF/ath_procfs.c
+++ b/CORE/SERVICES/HIF/ath_procfs.c
@@ -167,10 +167,17 @@ static ssize_t ath_procfs_diag_write(struct file *file, const char __user *buf,
 	}
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+static const struct proc_ops athdiag_proc_ops = {
+	.proc_read = ath_procfs_diag_read,
+	.proc_write = ath_procfs_diag_write,
+};
+#else
 static const struct file_operations athdiag_fops = {
 	.read = ath_procfs_diag_read,
 	.write = ath_procfs_diag_write,
 };
+#endif
 
 /**
  *This function is called when the module is loaded
@@ -185,10 +192,15 @@ int athdiag_procfs_init(void *scn)
 				PROCFS_DIR);
 		return -ENOMEM;
 	}
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+	proc_file = proc_create_data(PROCFS_NAME,
+					S_IRUSR | S_IWUSR, proc_dir,
+					&athdiag_proc_ops, (void *)scn);
+#else
 	proc_file = proc_create_data(PROCFS_NAME,
 					S_IRUSR | S_IWUSR, proc_dir,
 					&athdiag_fops, (void *)scn);
+#endif
 	if (proc_file == NULL) {
 		remove_proc_entry(PROCFS_NAME, proc_dir);
 		pr_debug("Error: Could not initialize /proc/%s\n",
diff --git a/CORE/SERVICES/HIF/hif_oob.c b/CORE/SERVICES/HIF/hif_oob.c
index 346b456..dd4223d 100644
--- a/CORE/SERVICES/HIF/hif_oob.c
+++ b/CORE/SERVICES/HIF/hif_oob.c
@@ -113,8 +113,12 @@ int hif_oob_claim_irq(oob_irq_handler_t handler, HIF_DEVICE *hif_device)
 	} else {
 		hif_oob->oob_irq_handler = handler;
 		hif_oob->oob_shutdown = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+		sched_set_fifo_low(hif_oob->oob_task);
+#else
 		sched_setscheduler(hif_oob->oob_task, SCHED_FIFO,
 				   &param);
+#endif
 		wake_up_process(hif_oob->oob_task);
 		up(&hif_oob->oob_sem);
 		AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("start oob task"));
diff --git a/CORE/SERVICES/HIF/sdio/hif_sdio_dev.c b/CORE/SERVICES/HIF/sdio/hif_sdio_dev.c
index d5fa860..93e9d2e 100644
--- a/CORE/SERVICES/HIF/sdio/hif_sdio_dev.c
+++ b/CORE/SERVICES/HIF/sdio/hif_sdio_dev.c
@@ -194,14 +194,20 @@ extern int rx_completion_task(void *param);
 static inline int hif_start_rx_completion_thread(HIF_SDIO_DEVICE *pDev)
 {
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
     struct sched_param param = {.sched_priority = 99};
+#endif
 #endif
 	if (!pDev->pRecvTask->rx_completion_task) {
 		pDev->pRecvTask->rx_completion_shutdown = 0;
 		pDev->pRecvTask->rx_completion_task = kthread_create(rx_completion_task,
 			(void *)pDev,	"AR6K RxCompletion");
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+                sched_set_fifo(pDev->pRecvTask->rx_completion_task);
+#else
                 sched_setscheduler(pDev->pRecvTask->rx_completion_task, SCHED_FIFO, &param);
+#endif
 #endif
 		if (IS_ERR(pDev->pRecvTask->rx_completion_task)) {
 			pDev->pRecvTask->rx_completion_shutdown = 1;
diff --git a/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c b/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c
index 8fea298..d73069a 100644
--- a/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c
+++ b/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c
@@ -1015,7 +1015,7 @@ int rx_completion_task(void *param)
         //alloc skb for next bundle
         adf_os_spin_lock_irqsave(&device->pRecvTask->rx_alloc_lock);
         while(HTC_PACKET_QUEUE_DEPTH(&device->pRecvTask->rxAllocQueue) < 64) {
-            pPacket = HIFDevAllocRxBuffer(device, target->TargetCreditSize);
+            pPacket = HIFDevAllocRxBuffer(device, 2048);
             if(pPacket == NULL) {
                 AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Short of mem, alloc failed"));
                 break;
diff --git a/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.h b/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.h
index ccb0d3c..a44c506 100644
--- a/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.h
+++ b/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.h
@@ -84,8 +84,10 @@ static inline void athdiag_procfs_remove(void) { return; }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
 #define DMA_MAPPING_ERROR(dev, addr) dma_mapping_error((addr))
-#else
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
 #define DMA_MAPPING_ERROR(dev, addr) dma_mapping_error((dev), (addr))
+#else
+/* DMA_MAPPING_ERROR is defined in kernel from 5.0.0 */
 #endif
 
 int ath_sdio_probe(void *context, void *hif_handle);
diff --git a/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c b/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c
index 54015ce..d9664ab 100644
--- a/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c
+++ b/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c
@@ -884,7 +884,9 @@ static inline void hif_free_bus_request(HIF_DEVICE *device,
 static inline int hif_start_tx_completion_thread(HIF_DEVICE *device)
 {
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
 	struct sched_param param = {.sched_priority = 99};
+#endif
 #endif
 	if (!device->tx_completion_task) {
 		device->tx_completion_req = NULL;
@@ -893,7 +895,11 @@ static inline int hif_start_tx_completion_thread(HIF_DEVICE *device)
 		device->tx_completion_task = kthread_create(tx_completion_task,
 			(void *)device,	"AR6K TxCompletion");
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+		sched_set_fifo(device->tx_completion_task);
+#else
 		sched_setscheduler(device->tx_completion_task, SCHED_FIFO, &param);
+#endif
 #endif
 		if (IS_ERR(device->tx_completion_task)) {
 			device->tx_completion_shutdown = 1;
@@ -2150,7 +2156,9 @@ static A_STATUS hifEnableFunc(HIF_DEVICE *device, struct sdio_func *func)
 {
     int ret = A_OK;
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
     struct sched_param param = {.sched_priority = 99};
+#endif
 #endif
     ENTER("sdio_func 0x%pK", func);
 
@@ -2263,7 +2271,11 @@ static A_STATUS hifEnableFunc(HIF_DEVICE *device, struct sdio_func *func)
                                            (void *)device,
                                            "AR6K Async");
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+           sched_set_fifo(device->async_task);
+#else
            sched_setscheduler(device->async_task, SCHED_FIFO, &param);
+#endif
 #endif
            if (IS_ERR(device->async_task)) {
                AR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("AR6000: %s(), to create async task\n", __FUNCTION__));
diff --git a/CORE/SERVICES/HTC/htc_internal.h b/CORE/SERVICES/HTC/htc_internal.h
index cb90a82..13a9121 100644
--- a/CORE/SERVICES/HTC/htc_internal.h
+++ b/CORE/SERVICES/HTC/htc_internal.h
@@ -32,25 +32,6 @@
 extern "C" {
 #endif /* __cplusplus */
 
-#if 0
-#include <adf_os_types.h>
-#include <adf_os_dma.h>
-#include <adf_os_timer.h>
-#include <adf_os_time.h>
-#include <adf_os_lock.h>
-#include <adf_os_io.h>
-#include <adf_os_mem.h>
-#include <adf_os_module.h>
-
-#include <adf_os_util.h>
-#include <adf_os_stdtypes.h>
-#include <adf_os_defer.h>
-#include <adf_os_atomic.h>
-//#include <adf_os_bitops.h>
-#include <adf_nbuf.h>
-#include <adf_net.h>
-
-#endif
 #include <athdefs.h>
 #include "a_types.h"
 #include "osapi_linux.h"
diff --git a/CORE/SERVICES/WMA/wma.c b/CORE/SERVICES/WMA/wma.c
index 4836bfc..9c86d5e 100644
--- a/CORE/SERVICES/WMA/wma.c
+++ b/CORE/SERVICES/WMA/wma.c
@@ -5462,10 +5462,8 @@ static int wma_unified_link_radio_stats_event_handler(void *handle,
 		 * events may be spoofed. Drop all of them and report error.
 		 */
 		WMA_LOGE("Invalid following WMI_RADIO_LINK_STATS_EVENTID. Discarding this set");
-		rs_results->tx_time_per_power_level = NULL;
 		vos_mem_free(wma_handle->link_stats_results);
 		wma_handle->link_stats_results = NULL;
-		vos_mem_free(rs_results->tx_time_per_power_level);
 		return -EINVAL;
 	}
 
diff --git a/CORE/SME/src/QoS/sme_Qos.c b/CORE/SME/src/QoS/sme_Qos.c
index 0b567bf..93f6829 100644
--- a/CORE/SME/src/QoS/sme_Qos.c
+++ b/CORE/SME/src/QoS/sme_Qos.c
@@ -4966,7 +4966,7 @@ eHalStatus sme_QosProcessHandoffAssocReqEv(tpAniSirGlobal pMac, v_U8_t sessionId
                break;
             }
 #endif
-
+            fallthrough;
          case SME_QOS_CLOSED:
          case SME_QOS_INIT:
          default:
@@ -7113,7 +7113,7 @@ eHalStatus sme_QosReassocSuccessEvFnp(tpAniSirGlobal pMac, tListElem *pEntry)
       break;
    case SME_QOS_REASON_RELEASE:
       pACInfo->num_flows[SME_QOS_TSPEC_INDEX_0]--;
-      // fall through
+      fallthrough;
    case SME_QOS_REASON_MODIFY:
       delete_entry = VOS_TRUE;
       break;
@@ -7160,7 +7160,7 @@ eHalStatus sme_QosReassocSuccessEvFnp(tpAniSirGlobal pMac, tListElem *pEntry)
       break;
    case SME_QOS_REASON_REQ_SUCCESS:
       hdd_status = SME_QOS_STATUS_SETUP_MODIFIED_IND;
-      // fall through
+      fallthrough;
    default:
       delete_entry = VOS_FALSE;
       break;
@@ -7249,6 +7249,7 @@ eHalStatus sme_QosAddTsFailureFnp(tpAniSirGlobal pMac, tListElem *pEntry)
       break;
    case SME_QOS_REASON_MODIFY:
       flow_info->reason = SME_QOS_REASON_REQ_SUCCESS;
+      fallthrough;
    case SME_QOS_REASON_REQ_SUCCESS:
    default:
       inform_hdd = VOS_FALSE;
@@ -7472,6 +7473,7 @@ eHalStatus sme_QosAddTsSuccessFnp(tpAniSirGlobal pMac, tListElem *pEntry)
    case SME_QOS_REASON_REQ_SUCCESS:
       hdd_status = SME_QOS_STATUS_SETUP_MODIFIED_IND;
       inform_hdd = VOS_TRUE;
+      fallthrough;
    default:
       delete_entry = VOS_FALSE;
       break;
diff --git a/CORE/SME/src/csr/csrApiRoam.c b/CORE/SME/src/csr/csrApiRoam.c
index d955cdb..fd98f03 100644
--- a/CORE/SME/src/csr/csrApiRoam.c
+++ b/CORE/SME/src/csr/csrApiRoam.c
@@ -9823,7 +9823,7 @@ void csrRoamJoinedStateMsgProcessor( tpAniSirGlobal pMac, void *pMsgBuf )
             tCsrRoamSession  *pSession;
             tSirSmeAssocIndToUpperLayerCnf *pUpperLayerAssocCnf;
             tCsrRoamInfo *roam_info;
-            tANI_U32 sessionId;
+            tANI_U32 sessionId = CSR_ROAM_SESSION_MAX;
             eHalStatus status;
             smsLog( pMac, LOG1, FL("ASSOCIATION confirmation can be given to upper layer "));
             pUpperLayerAssocCnf = (tSirSmeAssocIndToUpperLayerCnf *)pMsgBuf;
@@ -13592,6 +13592,7 @@ static void csrRoamGetBssStartParms(tpAniSirGlobal pMac,
 	default:
 		smsLog(pMac, LOGE, FL("sees an unknown pSirNwType (%d)"),
 				nwType);
+		fallthrough;
 	case eSIR_11A_NW_TYPE:
 		csr_populate_default_rates(opr_rates, true, true);
 		if (eCSR_OPERATING_CHANNEL_ANY != operation_channel) {
@@ -17903,7 +17904,7 @@ eHalStatus csrGetSnr(tpAniSirGlobal pMac,
 {
    eHalStatus status = eHAL_STATUS_SUCCESS;
    vos_msg_t  msg;
-   tANI_U32 sessionId;
+   tANI_U32 sessionId = CSR_ROAM_SESSION_MAX;
 
    tAniGetSnrReq *pMsg;
 
@@ -19819,6 +19820,7 @@ eHalStatus csrPsOffloadIsFullPowerNeeded(tpAniSirGlobal pMac,
                     case eCsrForcedDisassoc:
                     case eCsrForcedDisassocMICFailure:
                         reason = eSME_LINK_DISCONNECTED_BY_HDD;
+                        fallthrough;
                     case eCsrSmeIssuedDisassocForHandoff:
                     case eCsrForcedDeauth:
                     case eCsrHddIssuedReassocToSameAP:
diff --git a/CORE/SME/src/csr/csrNeighborRoam.c b/CORE/SME/src/csr/csrNeighborRoam.c
index c284ff2..002f936 100644
--- a/CORE/SME/src/csr/csrNeighborRoam.c
+++ b/CORE/SME/src/csr/csrNeighborRoam.c
@@ -5098,6 +5098,7 @@ eHalStatus csrNeighborRoamIndicateDisconnect(tpAniSirGlobal pMac,
         case eCSR_NEIGHBOR_ROAM_STATE_PREAUTH_DONE:
             /* Stop pre-auth to reassoc interval timer */
             vos_timer_stop(&pSession->ftSmeContext.preAuthReassocIntvlTimer);
+            fallthrough;
         case eCSR_NEIGHBOR_ROAM_STATE_REPORT_SCAN:
         case eCSR_NEIGHBOR_ROAM_STATE_PREAUTHENTICATING:
             csr_neighbor_roam_state_transition(pMac,
@@ -5270,6 +5271,7 @@ eHalStatus csrNeighborRoamIndicateConnect(tpAniSirGlobal pMac,
 #endif
                 break;
             }
+            fallthrough;
             /* Fall through if the status is SUCCESS */
         case eCSR_NEIGHBOR_ROAM_STATE_INIT:
             /* Reset all the data structures here */
@@ -6139,7 +6141,7 @@ eHalStatus csrNeighborRoamCandidateFoundIndHdlr(tpAniSirGlobal pMac, void* pMsg)
          * purge non-P2P results from the past */
         csrScanFlushSelectiveResult(pMac, VOS_FALSE);
         /* Once it gets the candidates found indication from PE, will issue
-         * a scan req to PE with freshScan in scanreq structure set
+         * a scan req to PE with "freshScan" in scanreq structure set
          * as follows: 0x42 - Return & purge LFR scan results
          */
         status = csrScanRequestLfrResult(pMac, sessionId,
diff --git a/CORE/SME/src/pmc/pmc.c b/CORE/SME/src/pmc/pmc.c
index 838f9e6..14c7c39 100644
--- a/CORE/SME/src/pmc/pmc.c
+++ b/CORE/SME/src/pmc/pmc.c
@@ -3127,6 +3127,7 @@ eHalStatus pmcOffloadEnableStaPsHandler(tpAniSirGlobal pMac,
              */
              smsLog(pMac, LOGE, FL("Fail to issue eSmeCommandEnterBmps"));
          }
+         fallthrough;
        case eHAL_STATUS_PMC_NOT_NOW:
          /*
           * Some module voted against Power Save.
diff --git a/CORE/SME/src/sme_common/sme_Api.c b/CORE/SME/src/sme_common/sme_Api.c
index ea84279..3e29bb1 100644
--- a/CORE/SME/src/sme_common/sme_Api.c
+++ b/CORE/SME/src/sme_common/sme_Api.c
@@ -7409,7 +7409,7 @@ eHalStatus sme_OemDataReq(tHalHandle hHal,
  *
  * Return: eHAL_STATUS_SUCCESS on success, non-zero error code on failure.
  */
-eHalStatus sme_create_mon_session(tHalHandle hal_handle, tSirMacAddr bss_id)
+eHalStatus sme_create_mon_session(tHalHandle hal_handle, uint8_t *bss_id)
 {
 	eHalStatus status = eHAL_STATUS_SUCCESS;
 	struct sir_create_session *msg;
diff --git a/CORE/SVC/src/logging/wlan_logging_sock_svc.c b/CORE/SVC/src/logging/wlan_logging_sock_svc.c
index 6ed6c04..031e402 100644
--- a/CORE/SVC/src/logging/wlan_logging_sock_svc.c
+++ b/CORE/SVC/src/logging/wlan_logging_sock_svc.c
@@ -31,7 +31,7 @@
  ******************************************************************************/
 
 #ifdef WLAN_LOGGING_SOCK_SVC_ENABLE
-#include <vmalloc.h>
+#include <linux/vmalloc.h>
 #include <wlan_nlink_srv.h>
 #include <vos_status.h>
 #include <vos_trace.h>
@@ -39,7 +39,7 @@
 #include <wlan_logging_sock_svc.h>
 #include <vos_types.h>
 #include <vos_trace.h>
-#include <kthread.h>
+#include <linux/kthread.h>
 #include <adf_os_time.h>
 #include "pktlog_ac.h"
 #include <linux/rtc.h>
@@ -282,9 +282,14 @@ int wlan_log_to_user(VOS_TRACE_LEVEL log_level, char *to_be_sent, int length)
 	int total_log_len;
 	unsigned int *pfilled_length;
 	bool wake_up_thread = false;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0))
+	struct timespec64 tv;
+	time64_t local_time;
+#else
 	struct timeval tv;
-	struct rtc_time tm;
 	unsigned long local_time;
+#endif
+	struct rtc_time tm;
 	int radio;
 
 	radio = vos_get_radio_index();
@@ -310,14 +315,23 @@ int wlan_log_to_user(VOS_TRACE_LEVEL log_level, char *to_be_sent, int length)
 	} else {
 
 		/* Format the Log time R#: [hr:min:sec.microsec] */
-		do_gettimeofday(&tv);
+		vos_timer_get_timeval(&tv);
 		/* Convert rtc to local time */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0)
+		local_time = (u64)(tv.tv_sec - (sys_tz.tz_minuteswest * 60));
+		rtc_time64_to_tm(local_time, &tm);
+		tlen = snprintf(tbuf, sizeof(tbuf),
+				"R%d: [%s][%02d:%02d:%02d.%06lu] ",
+				radio, current->comm, tm.tm_hour,
+				tm.tm_min, tm.tm_sec, (tv.tv_nsec / 1000));
+#else
 		local_time = (u32)(tv.tv_sec - (sys_tz.tz_minuteswest * 60));
 		rtc_time_to_tm(local_time, &tm);
 		tlen = snprintf(tbuf, sizeof(tbuf),
 				"R%d: [%s][%02d:%02d:%02d.%06lu] ",
 				radio, current->comm, tm.tm_hour,
 				tm.tm_min, tm.tm_sec, tv.tv_usec);
+#endif
 
 		/* 1+1 indicate '\n'+'\0' */
 		total_log_len = length + tlen + 1 + 1;
@@ -547,8 +561,8 @@ err:
 	 * Free old skb in case or error before assigning new skb
 	 * to the free list.
 	 */
-	if (free_old_skb)
-		dev_kfree_skb(pstats_msg->skb);
+		if (free_old_skb)
+			dev_kfree_skb(pstats_msg->skb);
 
 		adf_os_spin_lock_irqsave(&gwlan_logging.pkt_stats_lock);
 		pstats_msg->skb = skb_new;
diff --git a/CORE/UTILS/FWLOG/dbglog_host.c b/CORE/UTILS/FWLOG/dbglog_host.c
index 35390e1..44545df 100644
--- a/CORE/UTILS/FWLOG/dbglog_host.c
+++ b/CORE/UTILS/FWLOG/dbglog_host.c
@@ -4951,7 +4951,7 @@ int create_peer_cfr_debug_entry(tp_wma_handle wma, void *buf)
     debugfs_create_file(CFR_DEBUGFS_CAPT, 0644 , peer->cfr_peer_mac,
                         peer, &fops_cfr_capture);
 
-    AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("DEBUGFS PEER MAC = 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x",
+    AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("DEBUGFS PEER MAC = 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\n",
                                       peer->mac_addr.raw[0], peer->mac_addr.raw[1],
                                       peer->mac_addr.raw[2], peer->mac_addr.raw[3],
                                       peer->mac_addr.raw[4], peer->mac_addr.raw[5]));
diff --git a/CORE/UTILS/PKTLOG/linux_ac.c b/CORE/UTILS/PKTLOG/linux_ac.c
index 0560288..50a06b7 100644
--- a/CORE/UTILS/PKTLOG/linux_ac.c
+++ b/CORE/UTILS/PKTLOG/linux_ac.c
@@ -87,11 +87,19 @@ static int pktlog_release(struct inode *i, struct file *f);
 static ssize_t pktlog_read(struct file *file, char *buf, size_t nbytes,
 			   loff_t * ppos);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+static struct proc_ops pktlog_proc_ops = {
+	proc_open:pktlog_open,
+	proc_release:pktlog_release,
+	proc_read:pktlog_read,
+};
+#else
 static struct file_operations pktlog_fops = {
 	open:pktlog_open,
 	release:pktlog_release,
 	read:pktlog_read,
 };
+#endif
 
 /*
  * Linux implementation of helper functions
@@ -493,8 +501,17 @@ static int pktlog_attach(struct ol_softc *scn)
 	/* pl_dev->tgt_pktlog_enabled = false; */
 	pl_info_lnx->proc_entry = NULL;
 	pl_info_lnx->sysctl_header = NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+	proc_entry = proc_create_data(proc_name, PKTLOG_PROC_PERM,
+				      g_pktlog_pde, &pktlog_proc_ops,
+				      &pl_info_lnx->info);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+	if (proc_entry == NULL) {
+		printk(PKTLOG_TAG "%s: create_proc_entry failed for %s\n",
+		       __func__, proc_name);
+		goto attach_fail1;
+	}
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 	proc_entry = proc_create_data(proc_name, PKTLOG_PROC_PERM,
 				      g_pktlog_pde, &pktlog_fops,
 				      &pl_info_lnx->info);
diff --git a/CORE/VOSS/inc/vos_cnss.h b/CORE/VOSS/inc/vos_cnss.h
index af55821..367f70f 100644
--- a/CORE/VOSS/inc/vos_cnss.h
+++ b/CORE/VOSS/inc/vos_cnss.h
@@ -157,10 +157,17 @@ static inline int vos_wlan_pm_control(bool vote)
 static inline void vos_lock_pm_sem(void) { return; }
 static inline void vos_release_pm_sem(void) { return; }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+static inline void vos_get_boottime_ts(struct timespec64 *ts)
+{
+	ktime_get_ts64(ts);
+}
+#else
 static inline void vos_get_boottime_ts(struct timespec *ts)
 {
 	ktime_get_ts(ts);
 }
+#endif
 
 static inline void *vos_get_virt_ramdump_mem(struct device *dev,
 						unsigned long *size)
@@ -185,6 +192,9 @@ static inline int vos_set_cpus_allowed_ptr(struct task_struct *task, ulong cpu)
 static inline void vos_device_self_recovery(struct device *dev) { return; }
 static inline void vos_request_pm_qos_type(int latency_type, u32 qos_val)
 {
+	/* if PM Request is needed for kernel v5.7 or higher use cpu_latency_qos_add_request()
+	   For now and SDMAC LEA 3.0, just call return as before.
+	 */
 	return;
 }
 static inline void vos_remove_pm_qos(void) { return; }
@@ -336,8 +346,11 @@ static inline void vos_pm_wake_lock_destroy(vos_wake_lock_t *lock)
 {
 	cnss_pm_wake_lock_destroy(&(lock->lock));
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+static inline void vos_get_monotonic_boottime_ts(struct timespec64 *ts)
+#else
 static inline void vos_get_monotonic_boottime_ts(struct timespec *ts)
+#endif
 {
         cnss_get_monotonic_boottime(ts);
 }
@@ -373,7 +386,11 @@ static inline int vos_wlan_get_dfs_nol(void *info, u16 info_len)
 	return cnss_wlan_get_dfs_nol(info, info_len);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+static inline void vos_get_boottime_ts(struct timespec64 *ts)
+#else
 static inline void vos_get_boottime_ts(struct timespec *ts)
+#endif
 {
         cnss_get_boottime(ts);
 }
diff --git a/CORE/VOSS/inc/vos_timer.h b/CORE/VOSS/inc/vos_timer.h
index f3d7baa..c098510 100644
--- a/CORE/VOSS/inc/vos_timer.h
+++ b/CORE/VOSS/inc/vos_timer.h
@@ -347,6 +347,24 @@ v_TIME_t vos_timer_get_system_ticks( v_VOID_t );
   ------------------------------------------------------------------------*/
 v_TIME_t vos_timer_get_system_time( v_VOID_t );
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+/**
+ * vos_timer_get_timeval() - get struct timeval
+ * tv: pointer to struct timespec64
+ *
+ * Return: void
+ */
+void vos_timer_get_timeval(struct timespec64 *tv);
+#else
+/**
+ * vos_timer_get_timeval() - get struct timeval
+ * tv: pointer to struct timeval
+ *
+ * Return: void
+ */
+void vos_timer_get_timeval(struct timeval *tv);
+#endif
+
 /**
  * vos_system_ticks() - get system ticks
  *
diff --git a/CORE/VOSS/inc/vos_types.h b/CORE/VOSS/inc/vos_types.h
index 623b373..19b8d1d 100644
--- a/CORE/VOSS/inc/vos_types.h
+++ b/CORE/VOSS/inc/vos_types.h
@@ -41,7 +41,7 @@
   Include Files
   ------------------------------------------------------------------------*/
 #include "i_vos_types.h"
-#include <string.h>
+#include <linux/string.h>
 
 /*--------------------------------------------------------------------------
   Preprocessor definitions and constants
diff --git a/CORE/VOSS/src/vos_api.c b/CORE/VOSS/src/vos_api.c
index e32a4af..60cb21d 100644
--- a/CORE/VOSS/src/vos_api.c
+++ b/CORE/VOSS/src/vos_api.c
@@ -3244,7 +3244,15 @@ void vos_svc_fw_shutdown_ind(struct device *dev)
 {
 	hdd_svc_fw_shutdown_ind(dev);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+v_U64_t vos_get_monotonic_boottime_ns(void)
+{
+	struct timespec64 ts;
 
+	ktime_get_ts64(&ts);
+	return timespec64_to_ns(&ts);
+}
+#else
 v_U64_t vos_get_monotonic_boottime_ns(void)
 {
 	struct timespec ts;
@@ -3252,6 +3260,7 @@ v_U64_t vos_get_monotonic_boottime_ns(void)
 	ktime_get_ts(&ts);
 	return timespec_to_ns(&ts);
 }
+#endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
 v_U64_t vos_get_bootbased_boottime_ns(void)
diff --git a/CORE/VOSS/src/vos_nvitem.c b/CORE/VOSS/src/vos_nvitem.c
index e0f56c1..7152f3d 100644
--- a/CORE/VOSS/src/vos_nvitem.c
+++ b/CORE/VOSS/src/vos_nvitem.c
@@ -68,6 +68,13 @@
 #define IEEE80211_CHAN_NO_IBSS IEEE80211_CHAN_NO_IR
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)) || defined(WITH_BACKPORTS)
+extern int regulatory_hint_user(const char *alpha2,
+			 enum nl80211_user_reg_hint_type user_reg_hint_type);
+#else
+extern int regulatory_hint_user(const char *alpha2);
+#endif
+
 static v_REGDOMAIN_t temp_reg_domain = REGDOMAIN_COUNT;
 /* true if init happens thru init time driver hint */
 static v_BOOL_t init_by_driver = VOS_FALSE;
diff --git a/CORE/VOSS/src/vos_packet.c b/CORE/VOSS/src/vos_packet.c
index c0381e8..e282710 100644
--- a/CORE/VOSS/src/vos_packet.c
+++ b/CORE/VOSS/src/vos_packet.c
@@ -331,7 +331,7 @@ void vos_pkt_trace_buf_update
 )
 {
    v_U32_t slot;
-   struct timeval tv;
+   struct timespec64 tv;
 
    VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO,
              "%s %d, %s", __func__, __LINE__, event_string);
@@ -347,9 +347,9 @@ void vos_pkt_trace_buf_update
    trace_buffer[slot].order = trace_buffer_order;
    trace_buffer_order++;
    adf_os_spin_unlock_bh(&trace_buffer_lock);
-   do_gettimeofday(&tv);
+   ktime_get_real_ts64(&tv);
    trace_buffer[slot].event_sec_time = tv.tv_sec;
-   trace_buffer[slot].event_msec_time = tv.tv_usec;
+   trace_buffer[slot].event_msec_time = tv.tv_nsec / 1000;
    strlcpy(trace_buffer[slot].event_string, event_string,
           sizeof(trace_buffer[slot].event_string));
 
@@ -365,11 +365,11 @@ void vos_pkt_trace_buf_update
 void vos_pkt_trace_dump_slot_buf(int slot)
 {
 	struct rtc_time tm;
-	unsigned long local_time;
+	time64_t local_time;
 
-	local_time = (u32)(trace_buffer[slot].event_sec_time -
+	local_time = (u64)(trace_buffer[slot].event_sec_time -
 		(sys_tz.tz_minuteswest * 60));
-	rtc_time_to_tm(local_time, &tm);
+	rtc_time64_to_tm(local_time, &tm);
 	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
 		"%5d : [%02d:%02d:%02d.%06lu] : %s",
 		trace_buffer[slot].order,
diff --git a/CORE/VOSS/src/vos_sched.c b/CORE/VOSS/src/vos_sched.c
index dc89f52..4c9c57b 100644
--- a/CORE/VOSS/src/vos_sched.c
+++ b/CORE/VOSS/src/vos_sched.c
@@ -504,8 +504,10 @@ vos_sched_open
 {
   VOS_STATUS  vStatus = VOS_STATUS_SUCCESS;
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
   struct sched_param param = {.sched_priority = 99};
 #endif
+#endif
 /*-------------------------------------------------------------------------*/
   VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
              "%s: Opening the VOSS Scheduler",__func__);
@@ -597,7 +599,11 @@ vos_sched_open
                                                  pSchedContext,
                                                  "VosTlshimRxThread");
 #ifdef CONFIG_PERF_NON_QC_PLATFORM
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+  sched_set_fifo(pSchedContext->TlshimRxThread);
+#else
   sched_setscheduler(pSchedContext->TlshimRxThread, SCHED_FIFO, &param);
+#endif
 #endif
   if (IS_ERR(pSchedContext->TlshimRxThread))
   {
diff --git a/CORE/VOSS/src/vos_timer.c b/CORE/VOSS/src/vos_timer.c
index d38fe59..0f241b5 100644
--- a/CORE/VOSS/src/vos_timer.c
+++ b/CORE/VOSS/src/vos_timer.c
@@ -866,18 +866,84 @@ v_TIME_t vos_timer_get_system_ticks( v_VOID_t )
   \sa
 
   ------------------------------------------------------------------------*/
-v_TIME_t vos_timer_get_system_time( v_VOID_t )
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0))
+v_TIME_t vos_timer_get_system_time(void)
+{
+	struct timespec64 tv;
+
+	ktime_get_real_ts64(&tv);
+	return tv.tv_sec * 1000 + tv.tv_nsec / 1000000;
+}
+#else
+v_TIME_t vos_timer_get_system_time(void)
 {
    struct timeval tv;
    do_gettimeofday(&tv);
    return tv.tv_sec*1000 + tv.tv_usec/1000;
 }
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+void vos_timer_get_timeval(struct timespec64 *tv)
+{
+	struct timespec64 tv_spec;
+
+	ktime_get_real_ts64(&tv_spec);
+	tv->tv_sec = tv_spec.tv_sec;
+	tv->tv_nsec = tv_spec.tv_nsec;
+}
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0))
+void vos_timer_get_timeval(struct timeval *tv)
+{
+	struct timespec64 tv_spec;
+
+	ktime_get_real_ts64(&tv_spec);
+	tv->tv_sec = tv_spec.tv_sec;
+	tv->tv_usec = tv_spec.tv_nsec / 1000;
+}
+#else
+void vos_timer_get_timeval(struct timeval *tv)
+{
+	do_gettimeofday(tv);
+}
+#endif
 
 /**
  * vos_get_time_of_the_day_ms() - get time in milisec
  *
  * Return: time of the day in ms
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+unsigned long vos_get_time_of_the_day_ms(void)
+{
+	struct timespec64 tv;
+	time64_t local_time;
+	struct rtc_time tm;
+
+	ktime_get_real_ts64(&tv);
+	local_time = (tv.tv_sec - (sys_tz.tz_minuteswest * 60));
+	rtc_time64_to_tm(local_time, &tm);
+
+	return (tm.tm_hour * 60 * 60 * 1000) +
+		(tm.tm_min * 60 * 1000) + (tm.tm_sec * 1000) +
+		(tv.tv_nsec / 1000000);
+}
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0))
+unsigned long vos_get_time_of_the_day_ms(void)
+{
+	struct timespec64 tv;
+	unsigned long local_time;
+	struct rtc_time tm;
+
+	ktime_get_real_ts64(&tv);
+	local_time = (unsigned long)(tv.tv_sec - (sys_tz.tz_minuteswest * 60));
+	rtc_time_to_tm(local_time, &tm);
+
+	return (tm.tm_hour * 60 * 60 * 1000) +
+		(tm.tm_min * 60 * 1000) + (tm.tm_sec * 1000) +
+		(tv.tv_nsec / 1000000);
+}
+#else
 unsigned long vos_get_time_of_the_day_ms(void)
 {
 	struct timeval tv;
@@ -893,7 +959,41 @@ unsigned long vos_get_time_of_the_day_ms(void)
 		(tm.tm_min *60 * 1000) + (tm.tm_sec * 1000)+
 		(tv.tv_usec/1000));
 }
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+void vos_get_time_of_the_day_in_hr_min_sec_usec(char *tbuf, int len)
+{
+	struct timespec64 tv;
+	struct rtc_time tm;
+	time64_t local_time;
+
+	/* Format the Log time R#: [hr:min:sec.microsec] */
+	ktime_get_real_ts64(&tv);
+	/* Convert rtc to local time */
+	local_time = (tv.tv_sec - (sys_tz.tz_minuteswest * 60));
+	rtc_time64_to_tm(local_time, &tm);
+	scnprintf(tbuf, len,
+		  "[%02d:%02d:%02d.%06lu]",
+		  tm.tm_hour, tm.tm_min, tm.tm_sec, tv.tv_nsec / 1000);
+}
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0))
+void vos_get_time_of_the_day_in_hr_min_sec_usec(char *tbuf, int len)
+{
+	struct timespec64 tv;
+	struct rtc_time tm;
+	unsigned long local_time;
 
+	/* Format the Log time R#: [hr:min:sec.microsec] */
+	ktime_get_real_ts64(&tv);
+	/* Convert rtc to local time */
+	local_time = (u32)(tv.tv_sec - (sys_tz.tz_minuteswest * 60));
+	rtc_time_to_tm(local_time, &tm);
+	scnprintf(tbuf, len,
+		  "[%02d:%02d:%02d.%06lu]",
+		  tm.tm_hour, tm.tm_min, tm.tm_sec, tv.tv_nsec / 1000);
+}
+#else
 void vos_get_time_of_the_day_in_hr_min_sec_usec(char *tbuf, int len)
 {
        struct timeval tv;
@@ -909,6 +1009,7 @@ void vos_get_time_of_the_day_in_hr_min_sec_usec(char *tbuf, int len)
                "[%02d:%02d:%02d.%06lu] ",
                tm.tm_hour, tm.tm_min, tm.tm_sec, tv.tv_usec);
 }
+#endif
 
 /**
  * vos_wdthread_init_timer_work() -  Initialize timer work
diff --git a/CORE/VOSS/src/vos_utils.c b/CORE/VOSS/src/vos_utils.c
index d6c4e7e..43a5e69 100644
--- a/CORE/VOSS/src/vos_utils.c
+++ b/CORE/VOSS/src/vos_utils.c
@@ -72,11 +72,14 @@
 #include <linux/ieee80211.h>
 #include <crypto/hash.h>
 #include <crypto/aes.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,12,0))
+#include <crypto/internal/cipher.h>
+#endif
 #include <wcnss_api.h>
 #ifdef CONFIG_CNSS
 #include <linux/qcomwlan_secif.h>
 #endif
-#include <errno.h>
+#include <linux/errno.h>
 
 #include "ieee80211_common.h"
 /*----------------------------------------------------------------------------
@@ -1094,3 +1097,6 @@ int vos_status_to_os_return(VOS_STATUS status)
 		return -EPERM;
 	}
 }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,12,0))
+MODULE_IMPORT_NS(CRYPTO_INTERNAL);
+#endif
diff --git a/Kbuild b/Kbuild
index de36730..a7fa064 100644
--- a/Kbuild
+++ b/Kbuild
@@ -796,7 +796,7 @@ VOSS_OBJS :=    $(VOSS_SRC_DIR)/vos_api.o \
 		$(VOSS_SRC_DIR)/vos_timer.o \
 		$(VOSS_SRC_DIR)/vos_trace.o \
 		$(VOSS_SRC_DIR)/vos_types.o \
-                $(VOSS_SRC_DIR)/vos_utils.o
+		$(VOSS_SRC_DIR)/vos_utils.o
 
 ifeq ($(BUILD_DIAG_VERSION),1)
 VOSS_OBJS += $(VOSS_SRC_DIR)/vos_diag.o
@@ -1080,8 +1080,7 @@ CDEFINES :=	-DANI_LITTLE_BYTE_ENDIAN \
 		-DWLAN_FEATURE_GTK_OFFLOAD \
 		-DWLAN_WAKEUP_EVENTS \
 		-DFEATURE_WLAN_RA_FILTERING\
-	        -DWLAN_KD_READY_NOTIFIER \
-		-DWLAN_NL80211_TESTMODE \
+		-DWLAN_KD_READY_NOTIFIER \
 		-DFEATURE_WLAN_LPHB \
 		-DFEATURE_WLAN_PAL_TIMER_DISABLE \
 		-DFEATURE_WLAN_PAL_MEM_DISABLE \
@@ -1098,6 +1097,10 @@ CDEFINES :=	-DANI_LITTLE_BYTE_ENDIAN \
 		-DATH_SUPPORT_DFS \
 		-DWMI_COEX_BTC_DUTYCYCLE
 
+ifeq ($(CONFIG_NL80211_TESTMODE), y)
+CDEFINES +=	-DWLAN_NL80211_TESTMODE
+endif
+
 ifeq ($(CONFIG_WLAN_POWER_DEBUGFS), y)
 CDEFINES += -DWLAN_POWER_DEBUGFS
 endif
-- 
2.14.5

